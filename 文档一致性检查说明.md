# 文档一致性检查系统 - 使用说明

## 功能概述

在你的文档生成系统中，用户生成了多份文档后，修改某个文档的某个点时，**系统自动检查其他文档是否需要同步修改**，确保全局一致性。

## 工作原理

```
用户修改 "论文1.md" 中的某个概念
    ↓
系统调用外部RAG检索相关文档片段
    ↓
提取涉及的file_path列表
    ↓
AI分析哪些文档需要同步修改
    ↓
生成修改建议并显示diff对比
```

## 使用场景

### 场景1: 术语统一

**情况**: 用户在系统中生成了3篇论文，都提到"LSTM模型"。现在要把 `论文1.md` 的LSTM改成Transformer。

**系统行为**:
1. 检测到用户修改了"LSTM"相关内容
2. 调用RAG搜索包含"LSTM"的所有文档片段
3. 发现 `论文2.md` 和 `论文3.md` 也提到LSTM  
4. AI分析后建议同步修改
5. 返回每个文档的修改前后对比

---

### 场景2: 数据更新

**情况**: 用户生成的多篇报告中引用了2022年数据，现在要更新到2024年。

**系统行为**:
1. 用户修改 `报告1.md` 的2022年数据
2. 系统搜索所有包含"2022年"的文档
3. 建议其他报告也同步更新
4. 生成统一的修改方案

---

### 场景3: 方法改进

**情况**: 多篇论文采用相同的实验方法，现在要改进其中一个参数设置。

**系统行为**:
1. 检测到实验参数修改
2. 找出所有使用相同方法的文档
3. 生成一致性修改建议

---

## API使用

### 端点: `POST /check-consistency`

### 请求参数

```json
{
  "modification_point": "早季分类",  // 修改的关键点（用于RAG检索）
  "modification_request": "将LSTM模型改为Transformer模型",  // 具体修改要求
  "project_id": "test202511241125",  // 项目ID
  "current_file": "论文1.md",  // 当前修改的文件
  "current_file_content": "...当前文件完整内容...",
  "current_modification": "...修改后的示例内容...",
  "top_k": 10  // RAG召回数量
}
```

### 参数说明

- **modification_point**: RAG搜索关键词，如"早季分类"、"LSTM模型"、"2022年数据"
- **modification_request**: 告诉AI如何修改
- **project_id**: RAG系统的项目ID
- **current_file**: 当前编辑的文件路径（用于排除，避免重复）
- **current_file_content**: 原文内容（可选）
- **current_modification**: 修改示例（帮助AI理解修改风格）
- **top_k**: RAG召回多少个相关片段

### 响应结果

```json
{
  "success": true,
  "modification_point": "早季分类",
  "related_files": {
    "论文2.md": [
      {
        "content": "...相关内容片段...",
        "score": 0.89,
        "metadata": {"file_path": "论文2.md"}
      }
    ],
    "论文3.md": [...]
  },
  "total_files": 2,
  "consistency_analysis": {
    "needs_modification": ["论文2.md", "论文3.md"],
    "modification_type": "模型替换",
    "consistency_analysis": "这些文档都使用了LSTM模型，需要统一改为Transformer以保持一致性",
    "global_consistency_required": true
  },
  "modifications": [
    {
      "file_path": "论文2.md",
      "original_content": "...原文完整内容...",
      "modified_content": "...修改后内容...",
      "diff_summary": "行数变化: +5，原120行 → 新125行",
      "original_length": 3456,
      "modified_length": 3678
    }
  ],
  "message": "找到 2 个相关文档，需要修改 2 个"
}
```

---

## Python客户端示例

```python
import requests

# 用户正在修改 论文1.md，把LSTM改成Transformer
response = requests.post("http://localhost:8000/check-consistency", json={
    "modification_point": "LSTM模型",
    "modification_request": "将所有LSTM模型替换为Transformer模型，包括模型描述、参数配置、实验结果",
    "project_id": "my-papers-project",
    "current_file": "论文1.md",
    "current_file_content": open("论文1.md").read(),
    "current_modification": open("论文1-修改后.md").read(),
    "top_k": 15
})

result = response.json()

# 查看需要同步修改的文档
print(f"找到 {result['total_files']} 个相关文档")
print(f"需要修改: {result['consistency_analysis']['needs_modification']}")

# 查看每个文档的修改建议
for mod in result['modifications']:
    print(f"\n文件: {mod['file_path']}")
    print(f"原长度: {mod['original_length']}")
    print(f"新长度: {mod['modified_length']}")
    print(f"变化: {mod['diff_summary']}")
    
    # 可以在前端显示diff对比
    # show_diff(mod['original_content'], mod['modified_content'])
```

---

## 与RAG系统集成

系统使用你现有的外部RAG服务进行检索：

```python
# RAG请求示例
{
  "query": "早季分类",
  "project_id": "test202511241125",
  "top_k": 10,
  "use_refine": false,
  "metadata_filter": {
    "content_type": "file_chunk"  // 只召回文档片段类型
  }
}
```

### RAG返回格式期望

```json
{
  "bundles": [
    {
      "content": "...文档片段内容...",
      "score": 0.89,
      "metadata": {
        "file_path": "path/to/document.md",
        "source": "document.md",
        "content_type": "file_chunk"
      }
    }
  ]
}
```

---

## 前端集成建议

### 1. 编辑器中的一致性提示

```javascript
// 用户修改文档时
onDocumentChange(async (content) => {
  // 检测到关键修改（如删除/替换了某个重要术语）
  if (detectSignificantChange(content)) {
    const result = await checkConsistency({
      modification_point: extractKeyword(content),
      current_file_content: content,
      // ...
    });
    
    // 显示提示
    if (result.total_files > 0) {
      showNotification(`发现 ${result.total_files} 个相关文档可能需要同步修改`);
    }
  }
});
```

### 2. Diff可视化

```javascript
// 使用Monaco Diff Editor显示对比
import { DiffEditor } from '@monaco-editor/react';

<DiffEditor
  original={modification.original_content}
  modified={modification.modified_content}
  language="markdown"
  theme="vs-dark"
/>
```

### 3. 批量应用修改

```javascript
// 用户确认后批量应用
async function applyModifications(modifications) {
  for (const mod of modifications) {
    await saveDocument(mod.file_path, mod.modified_content);
  }
  showSuccess('所有文档已同步更新');
}
```

---

## 测试

运行测试脚本：

```bash
python test_consistency.py
```

测试脚本会：
1. ✓ 检查服务状态
2. ✓ 模拟一个修改场景
3. ✓ 调用RAG检索
4. ✓ 显示一致性分析
5. ✓ 展示修改建议和diff

---

## 配置

### 环境变量 (.env)

```bash
# OpenRouter API配置（用于AI分析和修改）
OPENROUTER_API_KEY=sk-or-v1-xxxxx
OPENROUTER_BASE_URL=https://openrouter.ai/api/v1
MODEL_NAME=x-ai/grok-4.1-fast:free
```

### RAG系统

确保你的RAG系统：
1. 支持 `metadata_filter` 参数
2. 返回结果包含 `file_path` 或 `source` 字段
3. 已经索引了生成的文档（content_type=file_chunk）

---

## 工作流程图

```
┌─────────────────────────────────────────────┐
│  用户在编辑器中修改文档                     │
│  例如: 论文1.md 中 "LSTM" → "Transformer"   │
└──────────────────┬──────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────┐
│  调用 /check-consistency API                │
│  - modification_point: "LSTM模型"           │
│  - project_id: "my-papers"                  │
└──────────────────┬──────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────┐
│  系统调用外部RAG检索                        │
│  POST http://rag-server/search              │
│  {                                          │
│    "query": "LSTM模型",                     │
│    "metadata_filter": {"content_type": ...}│
│  }                                          │
└──────────────────┬──────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────┐
│  解析RAG结果，提取file_path                 │
│  - 论文2.md (score: 0.92)                   │
│  - 论文3.md (score: 0.87)                   │
│  - 报告1.md (score: 0.81)                   │
└──────────────────┬──────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────┐
│  AI分析哪些文档需要修改                     │
│  分析结果:                                  │
│  - needs_modification: [论文2, 论文3]       │
│  - modification_type: "模型替换"            │
└──────────────────┬──────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────┐
│  为每个文档生成修改版本                     │
│  - 保持一致的修改风格                       │
│  - 参考当前文件的修改示例                   │
└──────────────────┬──────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────┐
│  返回结果给前端                             │
│  - 相关文档列表                             │
│  - 一致性分析                               │
│  - 每个文档的 original vs modified          │
└──────────────────┬──────────────────────────┘
                   │
                   ▼
┌─────────────────────────────────────────────┐
│  前端显示Diff对比                           │
│  用户可以:                                  │
│  - 预览每个文档的修改                       │
│  - 选择性应用修改                           │
│  - 一键批量应用所有修改                     │
└─────────────────────────────────────────────┘
```

---

## 注意事项

1. **RAG系统依赖**: 需要确保文档已上传到RAG系统并索引
2. **文件读取**: 当前实现使用RAG返回的chunks拼接，实际应读取完整文件
3. **大文档处理**: 对于超长文档，可能需要分段处理
4. **并发修改**: 注意处理多用户同时修改同一文档的情况

---

## 后续优化

1. **文件系统集成**: 直接从文件系统读取完整文档内容
2. **版本控制**: 集成git，自动创建修改分支
3. **智能触发**: 自动检测重要修改，无需手动触发
4. **修改历史**: 记录一致性修改历史，支持回滚

